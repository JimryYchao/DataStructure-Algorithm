### 分治策略

利用分治策略递归地求解一个问题：
- 分解（*Divide*）：将问题划分为一些子问题，子问题的形式与原问题一样，但规模更小。
- 解决（*Conquer*）：递归地求解子问题。问题规模足够小时，停止递归并直接解决。
- 合并（*Combine*）：将子问题的解组合成原问题的解。

>---
### 递归式

递归（*recursion*）通过不断逐层调用自身（递）直至达到终止条件时开始逐层返回（归），以解决一些算法问题。更多表现在将原问题分解为更多的子问题分治解决。

> *迭代*
> >
> >迭代（*iteration*）是一种重复执行某个任务的控制结构，直至条件不满足时停止迭代。常见有 `for` 迭代一定次数或 `while` 循环直至不满足条件控制。
> >
> >通常递归比迭代更耗费空间，函数调用也会产生额外的开销从而增加时间成本，因此时间效率也会更低。递归的深度受本地内存环境的限制，实际允许的递归深度通常是有限的。过高的深度可能会导致栈溢出。

当一个算法包含对其自身的调用时，可以用递归式或递归方程来描述其运行时间，递归式根据在较小输入规模上的运行时间来描述在规模为 $n$ 的问题上的总运行时间 $T(n)$。

当分治策略的子问题足够大时需要递归求解的情况为递归情况（*recursive case*）；当子问题规模足够小不需要递归时，则进入了基本情况（*base case*）。递归式与分治方法紧密相关，使用递归式可以自然地刻画分治算法的运行时间。一个递归式可以是一个等式或不等式，它通过更小输入规模上的函数值来描述一个函数。

分治算法运行时间的递归式来自基本模式的三个步骤。若问题规模足够小，例如对某个常量 $c$ 有 $n \leq c$，则所需的常量时间为 $Θ(1)$；假设将原问题分解为 $a$ 个子问题，每个子问题的规模是原问题的 $1/b$，则求解一个规模为 $n/b$ 的子问题需要 $T(n/b)$ 的时间，一共需要 $aT(n/b)$ 的时间来求解 $a$ 个子问题；分解时间需要 $D(n)$，合并子问题需要 $C(n)$，那么一个分治算法的递归式为：

$$T(n) = \begin{cases} Θ(1), & \text {if {$n \leq c$}}  \\
 aT(n/b) + D(n) + C(n), & \text{other} \end{cases}$$

如果对于每一个足够大的阈值常数 $n_0 > 0$，满足：
- 所有的 $∀ n < n_0$，$T(n) = Θ(1)$；
- 所有的 $∀ n \ge n_0$，在有限数量的递归调用中，每个递归路径都终止于一个实现定义的基本情况。

则描述分治算法运行时间 $T(n)$ 的递归式是算法的（*algorithmic*）。正确分治算法的最坏运行时间的递归式是算法递归。

>---
#### 引例：矩阵相乘

$A = (a_{ik})$ 和 $B = (b_{jk})$  是 $n \times n$ 的矩阵，对于 $C = A \cdot B$ 有 $c_ij = \sum^{n}_{k=1}a_{ik} \cdot b_{kj}$，$i,j=1,2,...,n$

```go

```

---